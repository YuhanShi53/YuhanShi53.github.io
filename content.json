{"meta":{"title":"Yuhan Shi","subtitle":"Han's blog","description":null,"author":"Yuhan Shi","url":"https://yuhanshi53.github.io"},"pages":[{"title":"Documents","date":"2018-07-13T14:23:57.470Z","updated":"2018-07-13T14:23:57.470Z","comments":true,"path":"categories/index.html","permalink":"https://yuhanshi53.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-07-14T15:02:15.374Z","updated":"2018-07-14T15:02:15.374Z","comments":false,"path":"about/index.html","permalink":"https://yuhanshi53.github.io/about/index.html","excerpt":"","text":"TBC"},{"title":"Tags","date":"2018-07-13T14:10:25.880Z","updated":"2018-07-13T14:10:25.880Z","comments":true,"path":"tags/index.html","permalink":"https://yuhanshi53.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode 5 Longest Palindromic Substring （With Manacher's Algorithms)","slug":"Leetcode-5-Longest-Palindromic-Substring","date":"2018-09-29T23:54:58.000Z","updated":"2018-09-29T17:45:50.174Z","comments":true,"path":"2018/09/30/Leetcode-5-Longest-Palindromic-Substring/","link":"","permalink":"https://yuhanshi53.github.io/2018/09/30/Leetcode-5-Longest-Palindromic-Substring/","excerpt":"QuestionGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example 2: Input: “cbbd”Output: “bb”","text":"QuestionGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example 2: Input: “cbbd”Output: “bb” Analysis回文子串就是字符串当中，正反念都是一样的子字符串，最简单的思路就是先用两个循环遍历所有子串，将每个子串反过来判断是否是回文串，然后找出最长的回文子串，这种方法除了两个循环，判断子串是否是回文串时，也用到了 O(n) 的时间复杂度，所以一共是 $O(n^3)$ 的时间复杂度，明显效率很低。网上还有动态规划的办法，但是效率也不是特别高。普通方法效率不高的主要原因就是重复遍历了一些子串，因此这里直接介绍时间复杂度为 O(n) 的 Manacher’s Algorithms，它借助已有的回文串的信息，减少了重复遍历的次数。 首先，回文串有可能关于中间的一个字符对称（奇数个字符），也有可能关于两个字符间的间隙对称（偶数个字符），因此我们先向每个间隙加入一个分隔字符（这里用”#”），这样所有回文串都会关于一个字符对称，这样做的原因稍后会解释。 接下来会问的问题就是，加了分隔字符后，怎么样从新的字符串中提取原回文串的长度，看下面一个例子。 abcba01234 #a#b#c#b#a#012345678910 原回文串的长度为5，加了分隔字符后，长度变为2*5+1，因此原回文串的长度就是新回文串的半径（包括中心）-1。这里是6-1。这样子就可以从新构造的回文串中求得原回文串的长度。接下来介绍，Manacher 如何借助已有的回文串，减少遍历次数。下图展示了一个回文串，假设这是已知边界最右的子回文串，回文串的中心记为 id，右边界记为 maxRight，目前遍历到了 i 处，每个位置的回文串半径用列表 R 储存，途中用红色笔记标出。 根据 i 的位置，这里需要分情况讨论： 假设 i 不在最右回文串以内 首先我们使R[i]=1，因为 i 超出了已知回文串的范围，无已有信息可以利用，只能暴力从 i 处开始向两边延伸，判断回文串长度。 假设 i 在最右回文串以内 我们找出 i 关于 id 对称的点 j (j=2*id-i)，由于回文串的对称性，R[i] 可能等于 R[j]。为什么是可能呢，这里也需要分情况讨论： j 为中心的回文串超出 id 为中心的回文串 此时 R[i] == maxRight-id+1，因为这种情况下 i 为中心的字符串不可能超出 id 为中心的字符串。 j 为中心的回文串在 id 为中心的回文串以内 如果 j 为中心的回文串没有达到 id 为中心的回文串边界，则根据对称性，R[i] == R[j]。反之，先将 R[i] == R[j]，再暴力拓展 i 为中心的回文串，找出回文串的最长范围，因为 i 为中心的回文串可能超出 id 为中心的回文串范围。 至此，R[i] 的值就可以定下来了。然后我们需要更新 maxRight 和 id。如果 i 为中心的回文串超出了原 id 为中心的回文串范围，我们需要将 id 更新为 i, 将 maxRight 更新为 i 为中心的回文串右边界。最后，我们需要得到的 R[i]，更新最长回文串。 Manacher’s Algorithms 十分巧妙地利用已经被发现的最右回文串以及它的对称性，极大的缩短了判断 R[i] 所需要的时间，在一些情况下甚至可以不用暴力寻找回文串就可以确定回文串长度，因此时间复杂度得到很好的优化。 为什么循环嵌套循环，时间复杂度还是 O(n)Code12345678910111213141516171819202122232425262728293031323334class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" if s is None or len(s) == 0: return '' # Preprocessing ss = '$#'+'#'.join(s) +'#' # add boundary ssLen = len(ss) maxLen = 0 id = 0 maxRight = 0 R = [0]*ssLen for i in range(ssLen): if i &lt; maxRight: R[i] = min(R[2*id-i], maxRight-i) else: R[i] = 1 if R[2*id-i] &gt; maxRight-id+1: pass else: while(i-R[i]&gt;=0 and i+R[i] &lt; ssLen and ss[i-R[i]] == ss[i+R[i]]): R[i]+=1 if R[i] &gt; maxLen: maxLen = R[i] longestPalinWithSeq = ss[i-R[i]+1:i+R[i]] if R[i]+i-1 &gt; maxRight: maxRight = R[i]+i-1 id = i longestPalin = longestPalinWithSeq[1:].replace('#','') # remove boundary return longestPalin","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leedcode 160 Intersection of Two Linked Lists","slug":"Leetcode-160-Intersection-of-Two-Linked-Lists","date":"2018-09-18T19:26:43.000Z","updated":"2018-09-18T12:39:06.526Z","comments":true,"path":"2018/09/19/Leetcode-160-Intersection-of-Two-Linked-Lists/","link":"","permalink":"https://yuhanshi53.github.io/2018/09/19/Leetcode-160-Intersection-of-Two-Linked-Lists/","excerpt":"QuestionWrite a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory.","text":"QuestionWrite a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. Analysis这个问题一般的思路是遍历两个链然后计算两个链表的长度，然后得到两个链表的长度差 n, 然后从长链表的第 n 个节点开始和短链表同时遍历，一一比较各个节点，如果发现相同的节点就说明有交集。这种方法下的时间复杂度为 O(n),而空间复杂度为 O(1)。 另一个思路的复杂度没有变化，不过比较巧妙。分配两个指针 pA 和 pB 分别从头遍历两个链表，并进行一一比较。如果两个链表长度相同，且有交集，则在遍历过程中必然会发现交集；如果两个链表长度不一样但也有交集，则我们使两个指针在遍历到链表末尾后跳到另一个链表头进行第二次遍历，两个指针最后会在第二次遍历时，同时达到交集起点。原因是：两个链表长度不一样时，两个指针在第二次遍历时到达交集起点时所经过的节点数一样，因此两个指针会在第二次遍历时同时到达交集起点。 这里需要注意，若两个链表有交集（intersection），则这两个链表从第一个交集开始，之后所有的节点都一样。 Code1234567891011121314151617181920# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\" if not headA or not headB: return None pA = headA pB = headB while(pA != pB): pA = headB if pA is None else pA.next pB = headA if pB is None else pB.next return pA","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"},{"name":"Linked Lists","slug":"Linked-Lists","permalink":"https://yuhanshi53.github.io/tags/Linked-Lists/"}]},{"title":"Leetcode 94 - Binary Tree Inorder Traversal （中值遍历）","slug":"Leetcode-94-Binary-Tree-Inorder-Traversal","date":"2018-08-02T12:30:45.000Z","updated":"2018-09-18T12:39:10.076Z","comments":true,"path":"2018/08/02/Leetcode-94-Binary-Tree-Inorder-Traversal/","link":"","permalink":"https://yuhanshi53.github.io/2018/08/02/Leetcode-94-Binary-Tree-Inorder-Traversal/","excerpt":"QuestionGiven a binary tree, return the inorder traversal of its nodes’ values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?","text":"QuestionGiven a binary tree, return the inorder traversal of its nodes’ values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? Analysis中值遍历是深度优先（Deep-first search）的一种树遍历方式，它先遍历节点左树（左节点），再输出节点自身，然后遍历右树（右节点）。流程如下图所示： 图片来自维基百科 这个问题可以采用递归或循环完成： 递归给递归函数传入一个节点，递归函数再调用自身并传入左子节点，遍历节点左侧；再输出节点自身的值；最后调用自身并传入右子节点，遍历右侧。当前节点为空时，不做处理。 循环循环中需要额外的栈用来储存当前节点下的左节点，当左节点遍历到底时，输出当前左子节点A的值，并将当前节点赋值为其右子节点B。如果右子节点B非空，则从右子节点B开始向下遍历其左子节点C；如果右子节点B为空，则 pop 出 stack 下一个值（即A的父节点）进行输出，然后继续上述循环。这里解释可能不清晰，所以采用字母区别节点，希望代码能够表达清楚思路。 Morris Traversal无论是递归还是循环，他们的时间复杂度都是O(n)，空间复杂度都是O(logn)，Morris Traversal 让部分右子节点指回某一级的节点，从而在循环中完成从子节点回到父节点的操作，而不使用额外的栈来储存节点。具体的原理解释不太易懂，这里用图示解释： Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def inorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" # Method 1 - Recursive # if root == None: # return [] # res = [] # self.inorderTraversalHelper(root, res) # return res # def inorderTraversalHelper(self, root, res): # if root: # self.inorderTraversalHelper(root.left, res) # res.append(root.val) # self.inorderTraversalHelper(root.right, res) # Method 2 - Iterative # if root == None: # return [] # stack = [] # res = [] # while(root!=None or len(stack)!=0): # while(root != None): # stack.append(root) # root = root.left # if(stack): # root = stack.pop() # res.append(root.val) # root = root.right # return res # Method 3 - Morris Traversal res = [] cur = root while(cur): if cur.left == None: res.append(cur.val) cur = cur.right else: pre = cur.left while(pre.right != None and pre.right != cur): pre = pre.right if pre.right == None: pre.right = cur cur = cur.left else: pre.right = None res.append(cur.val) cur = cur.right return res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"},{"name":"Tree","slug":"Tree","permalink":"https://yuhanshi53.github.io/tags/Tree/"}]},{"title":"Leetcode 328 - Odd Even Linked List","slug":"Leetcode-328-Odd-Even-Linked-List","date":"2018-08-01T10:51:18.000Z","updated":"2018-08-01T10:03:21.286Z","comments":true,"path":"2018/08/01/Leetcode-328-Odd-Even-Linked-List/","link":"","permalink":"https://yuhanshi53.github.io/2018/08/01/Leetcode-328-Odd-Even-Linked-List/","excerpt":"QuestionGiven a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL Example 2: Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULLOutput: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on …","text":"QuestionGiven a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL Example 2: Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULLOutput: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on … Analysis这个链表问题不是复杂，大致的思路就是将奇数序数的节点连在一起，将偶数序数的节点连在一起，最后将偶数链表接在奇数链表最后一个节点即可。相比于每次移动一个节点，使用奇偶两个 head 一次移动两个节点的遍历更加简洁，也不用多加判断语句和变量判断最后的节点序数是偶数还是奇数。 Code123456789101112131415161718192021222324# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def oddEvenList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return None odd = head even = head.next evenHead = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenHead return head","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 2 - Add Two Numbers","slug":"Leetcode-2-Add-Two-Numbers","date":"2018-07-31T20:30:38.000Z","updated":"2018-07-31T22:20:11.211Z","comments":true,"path":"2018/08/01/Leetcode-2-Add-Two-Numbers/","link":"","permalink":"https://yuhanshi53.github.io/2018/08/01/Leetcode-2-Add-Two-Numbers/","excerpt":"QuestionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.","text":"QuestionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Analysis这一道题在一刷的时候还没有特别的解决技巧，基本思路是分为三种情况： 两个链表节点都有值的时候，将两个节点的值加起来赋给新节点； 只有链表一的节点有值，将链表一节点的值赋给新节点 只有链表二的节点有值，将链表一节点的值赋给新节点这是最先想到的解法，代码在下方 Method One 中展示。 比较简化的思路是，只要链表一或者链表二存在有效值，就继续循环。如果链表一有值而链表二没有，则给链表二的节点赋值 ListNode(0) 用于计算；反之给链表一的节点赋值 ListNode(0)。这样操作省去了分情况讨论的复杂性，这个算法的代码在 Method Optimum 中展示。另外需要注意的是，当两个值相加超过9时，仅保留个位上的数字，并进位，因此需要额外的空间保存进位信息。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution: def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" # Method Two temp = ListNode(0) res = temp carry = 0 while l1 is not None or l2 is not None: l1 = l1 or ListNode(0) l2 = l2 or ListNode(0) total = l1.val+l2.val+carry carry = total//10 total %= 10 l1 = l1.next l2 = l2.next temp.next = ListNode(total) temp = temp.next if carry == 1: temp.next = ListNode(1) return res.next # Method One # temp = ListNode(0) # res = temp # addOne = 0 # while(l1 or l2 or addOne): # temp.next = ListNode(0) # temp = temp.next # if l1 and l2: # temp.val = l1.val+l2.val+addOne # l1 = l1.next # l2 = l2.next # elif l1: # temp.val = l1.val+addOne # l1 = l1.next # elif l2: # temp.val = l2.val+addOne # l2 = l2.next # else: # temp.val = 1 # addOne = temp.val // 10 # temp.val %= 10 # return res.next","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 334 - Increasing Triplet Subsequence","slug":"Leetcode-334-Increasing-Triplet-Subsequence","date":"2018-07-30T19:26:02.000Z","updated":"2018-08-01T09:52:50.221Z","comments":true,"path":"2018/07/31/Leetcode-334-Increasing-Triplet-Subsequence/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/31/Leetcode-334-Increasing-Triplet-Subsequence/","excerpt":"QuestionGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Note: Your algorithm should run in O(n) time complexity and O(1) space complexity. Example 1: Input: [1,2,3,4,5]Output: trueExample 2: Input: [5,4,3,2,1]Output: false","text":"QuestionGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Note: Your algorithm should run in O(n) time complexity and O(1) space complexity. Example 1: Input: [1,2,3,4,5]Output: trueExample 2: Input: [5,4,3,2,1]Output: false Analysis因为题目要求我们找到长度为3的递增子序列，因此我们可以设置两个指针 p1 和 p2，一个指向值较小的元素，一个指向值较大的元素在遍历序列的过程中，一旦遇到值比第二个值大，那么必然存在符合条件的子序列。在遍历的同时，如果遇到值小于 p1，则将新的值赋给 p1，如果新的值大于 p1， 小于 p2，则将新的值赋给 p2。这样做将递增序列的下限下调，便于更快地找到子序列第三个元素。 由于整个过程始终保证存在 p1 的值小于 p2，因此即便 p1 指向的值次序大于 p2, 一旦当前值大于 p2，一定能找到 p1 过去或现在的某个值组成递增序列。 Code123456789101112131415class Solution(object): def increasingTriplet(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" p1 = p2 = float('inf') for x in nums: if x &lt;= p1: p1 = x elif x &lt;= p2: p2 = x else: return True return False","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 101 - Symmetric Tree","slug":"Leetcode-101-Symmetric-Tree","date":"2018-07-20T15:47:30.000Z","updated":"2018-08-02T13:59:52.001Z","comments":true,"path":"2018/07/20/Leetcode-101-Symmetric-Tree/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/20/Leetcode-101-Symmetric-Tree/","excerpt":"QuestionGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3Note:Bonus points if you could solve it both recursively and iteratively.","text":"QuestionGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3Note:Bonus points if you could solve it both recursively and iteratively. Analysis要判断一个树是否对称，就是看同一层的节点是否关于中心对称。例如一层有8个节点，则应该有第一个节点值等于第八个节点值，第二个节点值等于第七个…因此在使用循环或者递归遍历树的的时候，应当使得每一步比较的两个节点位置关于中心对称。因此从每次向下遍历时，应当把每一层首位对应的两个节点送到下一步进行比较，而不是简单地把一个节点的左右子节点送到下一步。 Code12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def isSymmetric(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" # Iterate (Beat 100%) if root == None: return True stack = [root.left, root.right] while(stack): p, q = stack.pop(), stack.pop() if p == None and q == None: continue if p == None or q == None or p.val != q.val: return False stack.extend([p.left, q.right, p.right, q.left]) return True # Recursive# if root == None:# return True# return self.isSymmetricAssist(root.left, root.right) # def isSymmetricAssist(self, left, right):# \"\"\"# :type left: TreeNode# :type right: TreeNode# :rtype: bool# \"\"\"# if left == None or right == None:# return left == right# if left.val != right.val:# return False# return (self.isSymmetricAssist(left.left, right.right) and # self.isSymmetricAssist(left.right, right.left))","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"},{"name":"Algoroithms","slug":"Algoroithms","permalink":"https://yuhanshi53.github.io/tags/Algoroithms/"}]},{"title":"Leetcode 98 - Validate Binary Search Tree","slug":"Leetcode-98-Validate-Binary-Search-Tree","date":"2018-07-20T15:27:03.000Z","updated":"2018-07-20T14:44:10.737Z","comments":true,"path":"2018/07/20/Leetcode-98-Validate-Binary-Search-Tree/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/20/Leetcode-98-Validate-Binary-Search-Tree/","excerpt":"QuestionGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: Input: 2 / \\ 1 3 Output: true Example 2: 5 / \\ 1 4&nbsp; / \\&nbsp; 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node’s value&nbsp; is 5 but its right child’s value is 4.","text":"QuestionGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: Input: 2 / \\ 1 3 Output: true Example 2: 5 / \\ 1 4&nbsp; / \\&nbsp; 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node’s value&nbsp; is 5 but its right child’s value is 4. Analysis这道题需要判断对于每个节点其左边的子节点是不是都小于自身，同时右边的子节点是不是都大于自身。这种要求下使用中序遍历可以按照左节点-&gt;父节点-&gt;右节点的顺序，将树的每一个节点取出，并存在序列中。如果树是一个二叉搜索树，那么生成的序列中每一个元素都应当比其左边的元素大。如果比左边的元素小或者等于都说明不满足二叉搜索树的要求。 这里采用递归的方法遍历节点，根据中序遍历的顺序，先遍历左节点，再是父节点，最后是右节点。 Code12345678910111213141516171819202122232425class Solution(object): def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" if root == None: return True nodeOrder = [] self.nodeAppender(root, nodeOrder) for i in range(len(nodeOrder)-1): if nodeOrder[i] &gt;= nodeOrder[i+1]: return False return True def nodeAppender(self, root, nodeOrder): \"\"\" :type root: TreeNode :type nodeOrder: List[int] :rtype: No return \"\"\" if root: self.nodeAppender(root.left, nodeOrder) nodeOrder.append(root.val) self.nodeAppender(root.right, nodeOrder)","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 20 - Valid Parentheses","slug":"Leetcode-20-Valid-Parentheses","date":"2018-07-17T13:07:10.000Z","updated":"2018-07-17T12:15:39.294Z","comments":true,"path":"2018/07/17/Leetcode-20-Valid-Parentheses/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/17/Leetcode-20-Valid-Parentheses/","excerpt":"QuestionGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.Note that an empty string is also considered valid. Example 1: Input: “()”Output: true Example 2: Input: “()[]{}”Output: true Example 3: Input: “(]”Output: false Example 4: Input: “([)]”Output: false Example 5: Input: “{[]}”Output: true","text":"QuestionGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.Note that an empty string is also considered valid. Example 1: Input: “()”Output: true Example 2: Input: “()[]{}”Output: true Example 3: Input: “(]”Output: false Example 4: Input: “([)]”Output: false Example 5: Input: “{[]}”Output: true Analysis相比于采用多个 if else 来判断括号，使用字典储存括号对应关系并用于判断更加简洁。如果当前字符为 &#39;{([&#39; 之一，则往一个额外列表中添加左括号，否则如果额外列表为空，或者当前括号和额外列表最后一个括号不对应，则不符合规则。 Code1234567891011121314class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" dic = &#123;'&#123;': '&#125;', '(': ')', '[': ']'&#125; res = [] for x in s: if x in dic: res.append(x) elif not res or x != dic[res.pop()]: return False return not res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 268 - Missing Number","slug":"Leetcode-268-Missing-Number","date":"2018-07-17T12:55:13.000Z","updated":"2018-08-02T13:59:58.626Z","comments":true,"path":"2018/07/17/Leetcode-268-Missing-Number/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/17/Leetcode-268-Missing-Number/","excerpt":"QuestionGiven an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.","text":"QuestionGiven an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. Example 1: Input: [3,0,1]Output: 2 Example 2: Input: [9,6,4,2,3,5,7,0,1]Output: 8 Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Analysis因为 nums 的长度就是列表应有的最大值，因此获取列表长度后通过公式 $n(n+1)/2$ 就可以计算出列表应当有的和。用这个和减去列表实际的总和，就可以得出缺少的那一项。这个算法的时间复杂度为 $O(n)$，计算列表长度和列表总和需要遍历列表。空间复杂度为 $O(1)$。 Code12345678class Solution(object): def missingNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = len(nums) return n*(n+1)/2 - sum(nums)","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 13 - Roman to Integer","slug":"Leetcode-13-Roman-to-Integer","date":"2018-07-16T14:34:57.000Z","updated":"2018-08-02T13:59:19.759Z","comments":true,"path":"2018/07/16/Leetcode-13-Roman-to-Integer/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/16/Leetcode-13-Roman-to-Integer/","excerpt":"QuestionRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: “III”Output: 3Example 2: Input: “IV”Output: 4Example 3: Input: “IX”Output: 9Example 4: Input: “LVIII”Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3.Example 5: Input: “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.","text":"QuestionRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: “III”Output: 3Example 2: Input: “IV”Output: 4Example 3: Input: “IX”Output: 9Example 4: Input: “LVIII”Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3.Example 5: Input: “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Explanation因为包含特殊组合的罗马数字表示不同的含义，因此需要对 IXC 单独进行判断，但是常规方式的判断语句太多，不太简洁。简单的方式是将罗马数字逆序来看，如果是正常情况，则每一位罗马数字都应该不小于前一位，即 nums[i] &gt;= nums[i-1]。但如果需要通过组合表示 -1,-10,-100 的操作，则会出现当前一位罗马数字比前一位小的情况，例如 IV 的逆序 VI。nums[1] 小于 nums[0]，说明这里需要减去 nums[1] 即 1。重复以上的操作，当前位置数字大于等于前一位时，正常叠加，否则减去当前数字。 Code12345678910111213141516class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" dic = &#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; pre = 0 res = 0 for x in s[::-1]: if dic[x] &lt; pre: res -= dic[x] else: res += dic[x] pre = dic[x] return res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 326 - Power of Three","slug":"Leetcode-326-Power-of-Three","date":"2018-07-16T10:54:15.000Z","updated":"2018-07-16T10:27:38.715Z","comments":true,"path":"2018/07/16/Leetcode-326-Power-of-Three/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/16/Leetcode-326-Power-of-Three/","excerpt":"QuestionGiven an integer, write a function to determine if it is a power of three. Example 1: Input: 27Output: trueExample 2: Input: 0Output: falseExample 3: Input: 9Output: trueExample 4: Input: 45Output: false Follow up:Could you do it without using any loop / recursion?","text":"QuestionGiven an integer, write a function to determine if it is a power of three. Example 1: Input: 27Output: trueExample 2: Input: 0Output: falseExample 3: Input: 9Output: trueExample 4: Input: 45Output: false Follow up:Could you do it without using any loop / recursion? Explanation判断一个数 n 是不是3的幂，只需要以3为底求 n 的对数即可，是正整数返回 True ，否则返回 False 。代码中 log() 默认以 $e$ 为底，因此需要用到换底公式：$$log_{\\theta}{n} = \\frac{log_{\\epsilon}{n}}{log_{\\epsilon}{\\theta}}$$在 Python 中，由于精度的问题，求3为底 n 的对数可能得到不精确的结果，例如:12&gt;&gt;&gt; log(243,3)&gt;&gt;&gt; 4.999999999 因此需要将求出的对数四舍五入后作为3的指数求出结果，将结果和 n 对比，如果相等，则 n 是3的幂。 Code1234567891011from math import logclass Solution(object): def isPowerOfThree(self, n): \"\"\" :type n: int :rtype: bool \"\"\" if n &gt; 0: return 3**round(log(n,3)) == n return False","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 204 - Count Primes","slug":"Leetcode-204-Count-Primes","date":"2018-07-15T23:06:32.000Z","updated":"2018-08-02T13:59:16.004Z","comments":true,"path":"2018/07/16/Leetcode-204-Count-Primes/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/16/Leetcode-204-Count-Primes/","excerpt":"QuestionCount the number of prime numbers less than a non-negative number, n.","text":"QuestionCount the number of prime numbers less than a non-negative number, n. Example: Input: 10Output: 4Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Explanation判断一个数是否是质数最简单的方法是用所有比他小的正整数（1除外）去除它，如果都不能除尽，则这个数是质数，但是这样的时间复杂度将会是$O(n^2)$。这里需要用到埃拉托斯特尼筛法减少循环次数。埃拉托斯特尼筛法是从2开始，将2的正整数倍的数都标记为False，在之后的遍历过程中，标记为False的数将不再做素数的判断，因为他们都能被2整除。标记完之后，继续对下一个标记为True的数字（这里是3）进行筛选，直到最后一个数。如下为动态演示： source from wikipedia 这样筛选还是包含了一些不必要的计算，因为一个合数 $n$ 的因子必然小于 $ \\sqrt{n} $ ，因此对于 $ n \\in {1,N} $ ， 只需要排除小于 $ \\sqrt{N}+1 $ 的素数的倍数。至于大于等于 $ \\sqrt{n}+1 $ 的素数，它们的倍数要么被更小的素数筛完，要么大于 $N$ ，因此无需判断。 Code12345678910111213141516class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\" if n &lt; 2: return 0 nSqrt = int(n**0.5)+1 primeList = [True] * n primeList[0:2] = [False] * 2 for i in range(nSqrt): if primeList[i]: primeList[2*i:n:i] = [False]*len(range(2*i,n,i)) res = primeList.count(True) return res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 412 - Fizz Buzz","slug":"Leetcode-412-Fizz-Buzz","date":"2018-07-15T14:02:24.000Z","updated":"2018-08-02T13:59:17.230Z","comments":true,"path":"2018/07/15/Leetcode-412-Fizz-Buzz/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/Leetcode-412-Fizz-Buzz/","excerpt":"QuestionWrite a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.","text":"QuestionWrite a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15,Return:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] ExplanationThe judgement should judge i%15 first. Code12345678910111213141516171819class Solution(object): def fizzBuzz(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" if n == 0: return [] res = [] for i in range(1, n+1): if i%15 == 0: res.append('FizzBuzz') elif i%5 == 0: res.append('Buzz') elif i%3 == 0: res.append('Fizz') else: res.append(str(i)) return res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 155 - Min Stack","slug":"Leetcode-155-Min-Stack","date":"2018-07-15T13:27:49.000Z","updated":"2018-08-02T13:59:14.011Z","comments":true,"path":"2018/07/15/Leetcode-155-Min-Stack/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/Leetcode-155-Min-Stack/","excerpt":"QuestionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2.","text":"QuestionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. ExplanationUsing an addition list to the minimum value every time the stack is updated. Therefore, getMin() will not take O(n) time complexity. Appending the new value to the end of the list will reduce the complexity of changing the stack. Code123456789101112131415161718192021222324252627282930313233343536373839class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.stack = [] self.min = [] def push(self, x): \"\"\" :type x: int :rtype: void \"\"\" self.stack.append(x) if not self.min or self.min[-1] &gt; x: self.min.append(x) else: self.min.append(self.min[-1]) def pop(self): \"\"\" :rtype: void \"\"\" self.stack.pop() self.min.pop() def top(self): \"\"\" :rtype: int \"\"\" return(self.stack[-1]) def getMin(self): \"\"\" :rtype: int \"\"\" return self.min[-1]","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"House Robber","slug":"House-Robber","date":"2018-07-15T10:13:38.000Z","updated":"2018-08-02T13:59:29.510Z","comments":true,"path":"2018/07/15/House-Robber/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/House-Robber/","excerpt":"QuestionYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.","text":"QuestionYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 &gt; (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money &gt; = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. ExplanationThe maximum value the robber can get when he comes to a house is nums[i]+max(nums[i-2], nums[i-3]) when i-3 and i-2 exist. Therefore, we can separate the question into two situations. The first one is to determine the max reward when i&lt;=3. The second one is to calculate the maximum value for i based on the maximum value we get in nums[i-2] and nums[i-3]. Codeclass Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 elif len(nums) &lt; 3: return max(nums) elif len(nums) == 3: return max(nums[1], nums[0]+nums[2]) else: nums[2] += nums[0] globalMax = max(nums[1], nums[2]) for i in range(3, len(nums)): nums[i] += max(nums[i-2], nums[i-3]) globalMax = max(globalMax, nums[i]) return globalMax","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Merge sorted array","slug":"Merge-sorted-array","date":"2018-07-13T12:11:43.000Z","updated":"2018-07-15T09:16:17.599Z","comments":true,"path":"2018/07/13/Merge-sorted-array/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/Merge-sorted-array/","excerpt":"QuestionGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.","text":"QuestionGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 思路由于两个数组都已经排序，因此可以从后往前比较两个数组，将较大的元素插入未排序的部分。若数组1先排完，则说明数组2的剩余元素均比数组1小，所以将剩余部分填充完即可；若数组2先排完，则说明数组1剩余元素均小于数组2，由于合并是在数组1上原地完成，因此不需要再操作。 Code123456789101112131415161718192021222324class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" end = m+n-1 m -= 1 n -= 1 while end &gt;= 0 and m &gt;= 0 and n &gt;= 0: if nums1[m] &gt; nums2[n]: nums1[end] = nums1[m] m -= 1 else: nums1[end] = nums2[n] n -= 1 end -= 1 while n &gt;= 0: nums1[end] = nums2[n] n -= 1 end -= 1","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"First bad version","slug":"First-bad-version","date":"2018-07-13T00:14:01.000Z","updated":"2018-07-15T09:16:39.785Z","comments":true,"path":"2018/07/13/First-bad-version/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/First-bad-version/","excerpt":"QuestionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.","text":"QuestionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions 1, 2, ..., n and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; true Then 4 is the first bad version. 思路要做到减少判断的次数，最先想到的是二分法，不断取中值进行判断，缩小搜索范围。如果mid是bad version那么mid可能是第一个bad version，所以将右边界缩小到mid；如果mid不是bad version，那么first bad version一定在mid右侧，所以将左边界缩小至mid左侧，这里left = mid+1很重要。举个例子： 还剩两个值,比如1， 2时，因为(1+2)//2 == 1，所以此时mid为1，假设1不是bad version， left = mid还是等于1，将会陷入死循环。 最后范围被压缩到一个值，这个值就是The first bad version。 Code123456789101112131415class Solution(object): def firstBadVersion(self, n): \"\"\" :type n: int :rtype: int \"\"\" left = 1 right = n while left != right: mid = (left+right)//2 if isBadVersion(mid): right = mid else: left = mid+1 # mid is not the first bad version return left","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Maximum Subarray","slug":"Maximim-Subarray","date":"2018-07-13T00:05:23.000Z","updated":"2018-08-02T13:59:36.149Z","comments":true,"path":"2018/07/13/Maximim-Subarray/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/Maximim-Subarray/","excerpt":"QuestionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.","text":"QuestionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle ExplanationAssume the local maximum is the maximum value of the continuous subarray which must contain the current value pointed by the index i. The function of local maximum can be expressed as localMax[i] = max(nums[i], localMax[i-1]+nums[i]). This can be explained by the examples below: if localMax[i-1]&gt;0, nums[i]&gt;0 then localMax[i] = localMax[i-1]+nums[i] if localMax[i-1]&gt;0, nums[i]&lt;0 then localMax[i] = localMax[i-1]+nums[i] if localMax[i-1]&lt;0, nums[i]&gt;0 then localMax[i] = nums[i] if localMax[i-1]&lt;0, nums[i]&lt;0 then localMax[i] = nums[i] We also need a globalMax to store the global maximum value. In this case, although we take localMax[i-1]+nums[i] as local maximum which is smaller than localMax[i-1] when localMax[i-1]&gt;0, nums[i]&lt;0, we are still able to keep the localMax[i-1] with the existence of globalMax. With these two variables, we can get maximum of subarray with O(n) time complexity and O(1) space complexity. Code1234567891011121314151617181920212223242526272829class Solution: def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int Two methods here, just select one. \"\"\" # Time complexity O(n); Space complexity O(n) local = [nums[0]] globalMax = nums[0] for i in range(1,len(nums)): if local[-1] &gt; 0: local.append(local[-1]+nums[i]) else: local.append(nums[i]) globalMax = max(globalMax, local[-1]) return globalMax # Time complexity O(n); Space complexity O(1) if len(nums) == 0: return None elif len(nums) == 1: return nums[0] localMax = nums[0] globalMax = nums[0] for x in nums[1:]: localMax = max(x, localMax+x) globalMax = max(localMax, globalMax) return globalMax","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]}]}