{"meta":{"title":"Yuhan Shi","subtitle":"Han's blog","description":null,"author":"Yuhan Shi","url":"https://yuhanshi53.github.io"},"pages":[{"title":"Documents","date":"2018-07-13T14:23:57.470Z","updated":"2018-07-13T14:23:57.470Z","comments":true,"path":"categories/index.html","permalink":"https://yuhanshi53.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-07-14T15:02:15.374Z","updated":"2018-07-14T15:02:15.374Z","comments":false,"path":"about/index.html","permalink":"https://yuhanshi53.github.io/about/index.html","excerpt":"","text":"TBC"},{"title":"Tags","date":"2018-07-13T14:10:25.880Z","updated":"2018-07-13T14:10:25.880Z","comments":true,"path":"tags/index.html","permalink":"https://yuhanshi53.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"House Robber","slug":"House-Robber","date":"2018-07-15T10:13:38.000Z","updated":"2018-07-15T09:16:49.357Z","comments":true,"path":"2018/07/15/House-Robber/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/House-Robber/","excerpt":"","text":"House Robber@(Coding Tips)[Python, Algorithms] QuestionYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;! –more–&gt; Example 1: Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 &gt; (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money &gt; = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. ExplanationThe maximum value the robber can get when he comes to a house is nums[i]+max(nums[i-2], nums[i-3]) when i-3 and i-2 exist. Therefore, we can separate the question into two situations. The first one is to determine the max reward when i&lt;=3. The second one is to calculate the maximum value for i based on the maximum value we get in nums[i-2] and nums[i-3]. Codeclass Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 elif len(nums) &lt; 3: return max(nums) elif len(nums) == 3: return max(nums[1], nums[0]+nums[2]) else: nums[2] += nums[0] globalMax = max(nums[1], nums[2]) for i in range(3, len(nums)): nums[i] += max(nums[i-2], nums[i-3]) globalMax = max(globalMax, nums[i]) return globalMax","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Merge sorted array","slug":"Merge-sorted-array","date":"2018-07-13T12:11:43.000Z","updated":"2018-07-15T09:16:17.599Z","comments":true,"path":"2018/07/13/Merge-sorted-array/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/Merge-sorted-array/","excerpt":"QuestionGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.","text":"QuestionGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 思路由于两个数组都已经排序，因此可以从后往前比较两个数组，将较大的元素插入未排序的部分。若数组1先排完，则说明数组2的剩余元素均比数组1小，所以将剩余部分填充完即可；若数组2先排完，则说明数组1剩余元素均小于数组2，由于合并是在数组1上原地完成，因此不需要再操作。 Code123456789101112131415161718192021222324class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" end = m+n-1 m -= 1 n -= 1 while end &gt;= 0 and m &gt;= 0 and n &gt;= 0: if nums1[m] &gt; nums2[n]: nums1[end] = nums1[m] m -= 1 else: nums1[end] = nums2[n] n -= 1 end -= 1 while n &gt;= 0: nums1[end] = nums2[n] n -= 1 end -= 1","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"First bad version","slug":"First-bad-version","date":"2018-07-13T00:14:01.000Z","updated":"2018-07-15T09:16:39.785Z","comments":true,"path":"2018/07/13/First-bad-version/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/First-bad-version/","excerpt":"QuestionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.","text":"QuestionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions 1, 2, ..., n and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; true Then 4 is the first bad version. 思路要做到减少判断的次数，最先想到的是二分法，不断取中值进行判断，缩小搜索范围。如果mid是bad version那么mid可能是第一个bad version，所以将右边界缩小到mid；如果mid不是bad version，那么first bad version一定在mid右侧，所以将左边界缩小至mid左侧，这里left = mid+1很重要。举个例子： 还剩两个值,比如1， 2时，因为(1+2)//2 == 1，所以此时mid为1，假设1不是bad version， left = mid还是等于1，将会陷入死循环。 最后范围被压缩到一个值，这个值就是The first bad version。 Code123456789101112131415class Solution(object): def firstBadVersion(self, n): \"\"\" :type n: int :rtype: int \"\"\" left = 1 right = n while left != right: mid = (left+right)//2 if isBadVersion(mid): right = mid else: left = mid+1 # mid is not the first bad version return left","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Maximum Subarray","slug":"Maximim-Subarray","date":"2018-07-13T00:05:23.000Z","updated":"2018-07-15T09:16:29.483Z","comments":true,"path":"2018/07/13/Maximim-Subarray/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/Maximim-Subarray/","excerpt":"QuestionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.","text":"QuestionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle ExplanationAssume the local maximum is the maximum value of the continuous subarray which must contain the current value pointed by the index i. The function of local maximum can be expressed as localMax[i] = max(nums[i], localMax[i-1]+nums[i]). This can be explained by the examples below: if localMax[i-1]&gt;0, nums[i]&gt;0 then localMax[i] = localMax[i-1]+nums[i] if localMax[i-1]&gt;0, nums[i]&lt;0 then localMax[i] = localMax[i-1]+nums[i] if localMax[i-1]&lt;0, nums[i]&gt;0 then localMax[i] = nums[i] if localMax[i-1]&lt;0, nums[i]&lt;0 then localMax[i] = nums[i] We also need a globalMax to store the global maximum value. In this case, although we take localMax[i-1]+nums[i] as local maximum which is smaller than localMax[i-1] when localMax[i-1]&gt;0, nums[i]&lt;0, we are still able to keep the localMax[i-1] with the existence of globalMax. With these two variables, we can get maximum of subarray with O(n) time complexity and O(1) space complexity. Code1234567891011121314151617181920212223242526272829class Solution: def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int Two methods here, just select one. \"\"\" # Time complexity O(n); Space complexity O(n) local = [nums[0]] globalMax = nums[0] for i in range(1,len(nums)): if local[-1] &gt; 0: local.append(local[-1]+nums[i]) else: local.append(nums[i]) globalMax = max(globalMax, local[-1]) return globalMax # Time complexity O(n); Space complexity O(1) if len(nums) == 0: return None elif len(nums) == 1: return nums[0] localMax = nums[0] globalMax = nums[0] for x in nums[1:]: localMax = max(x, localMax+x) globalMax = max(localMax, globalMax) return globalMax","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]}]}