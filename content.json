{"meta":{"title":"Yuhan Shi","subtitle":"Han's blog","description":null,"author":"Yuhan Shi","url":"https://yuhanshi53.github.io"},"pages":[{"title":"About","date":"2018-07-14T15:02:15.374Z","updated":"2018-07-14T15:02:15.374Z","comments":false,"path":"about/index.html","permalink":"https://yuhanshi53.github.io/about/index.html","excerpt":"","text":"TBC"},{"title":"Tags","date":"2018-07-13T14:10:25.880Z","updated":"2018-07-13T14:10:25.880Z","comments":true,"path":"tags/index.html","permalink":"https://yuhanshi53.github.io/tags/index.html","excerpt":"","text":""},{"title":"Documents","date":"2018-07-13T14:23:57.470Z","updated":"2018-07-13T14:23:57.470Z","comments":true,"path":"categories/index.html","permalink":"https://yuhanshi53.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode 326 - Power of Three","slug":"Leetcode-326-Power-of-Three","date":"2018-07-16T10:54:15.000Z","updated":"2018-07-16T10:27:38.715Z","comments":true,"path":"2018/07/16/Leetcode-326-Power-of-Three/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/16/Leetcode-326-Power-of-Three/","excerpt":"QuestionGiven an integer, write a function to determine if it is a power of three. Example 1: Input: 27Output: trueExample 2: Input: 0Output: falseExample 3: Input: 9Output: trueExample 4: Input: 45Output: false Follow up:Could you do it without using any loop / recursion?","text":"QuestionGiven an integer, write a function to determine if it is a power of three. Example 1: Input: 27Output: trueExample 2: Input: 0Output: falseExample 3: Input: 9Output: trueExample 4: Input: 45Output: false Follow up:Could you do it without using any loop / recursion? Explanation判断一个数 n 是不是3的幂，只需要以3为底求 n 的对数即可，是正整数返回 True ，否则返回 False 。代码中 log() 默认以 $e$ 为底，因此需要用到换底公式：$$log_{\\theta}{n} = \\frac{log_{\\epsilon}{n}}{log_{\\epsilon}{\\theta}}$$在 Python 中，由于精度的问题，求3为底 n 的对数可能得到不精确的结果，例如:12&gt;&gt;&gt; log(243,3)&gt;&gt;&gt; 4.999999999 因此需要将求出的对数四舍五入后作为3的指数求出结果，将结果和 n 对比，如果相等，则 n 是3的幂。 Code1234567891011from math import logclass Solution(object): def isPowerOfThree(self, n): \"\"\" :type n: int :rtype: bool \"\"\" if n &gt; 0: return 3**round(log(n,3)) == n return False","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 204 - Count Primes","slug":"Leetcode-204-Count-Primes","date":"2018-07-15T23:06:32.000Z","updated":"2018-07-16T10:26:41.674Z","comments":true,"path":"2018/07/16/Leetcode-204-Count-Primes/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/16/Leetcode-204-Count-Primes/","excerpt":"QuestionCount the number of prime numbers less than a non-negative number, n.","text":"QuestionCount the number of prime numbers less than a non-negative number, n. Example: Input: 10Output: 4Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Explanation判断一个数是否是质数最简单的方法是用所有比他小的正整数（1除外）去除它，如果都不能除尽，则这个数是质数，但是这样的时间复杂度将会是$O(n^2)$。这里需要用到埃拉托斯特尼筛法减少循环次数。埃拉托斯特尼筛法是从2开始，将2的正整数倍的数都标记为False，在之后的遍历过程中，标记为False的数将不再做素数的判断，因为他们都能被2整除。标记完之后，继续对下一个标记为True的数字（这里是3）进行筛选，直到最后一个数。如下为动态演示： source from wikipedia 这样筛选还是包含了一些不必要的计算，因为一个合数 $n$ 的因子必然小于 $ \\sqrt{n} $ ，因此对于 $ n \\in {1,N} $ ， 只需要排除小于 $ \\sqrt{N}+1 $ 的素数的倍数。至于大于等于 $ \\sqrt{n}+1 $ 的素数，它们的倍数要么被更小的素数筛完，要么大于 $N$ ，因此无需判断。 Code12345678910111213141516class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\" if n &lt; 2: return 0 nSqrt = int(n**0.5)+1 primeList = [True] * n primeList[0:2] = [False] * 2 for i in range(nSqrt): if primeList[i]: primeList[2*i:n:i] = [False]*len(range(2*i,n,i)) res = primeList.count(True) return res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 412 - Fizz Buzz","slug":"Leetcode-412-Fizz-Buzz","date":"2018-07-15T14:02:24.000Z","updated":"2018-07-16T10:27:20.019Z","comments":true,"path":"2018/07/15/Leetcode-412-Fizz-Buzz/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/Leetcode-412-Fizz-Buzz/","excerpt":"QuestionWrite a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.","text":"QuestionWrite a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15,Return:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] ExplanationThe judgement should judge i%15 first. Code12345678910111213141516171819class Solution(object): def fizzBuzz(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" if n == 0: return [] res = [] for i in range(1, n+1): if i%15 == 0: res.append('FizzBuzz') elif i%5 == 0: res.append('Buzz') elif i%3 == 0: res.append('Fizz') else: res.append(str(i)) return res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 155 - Min Stack","slug":"Leetcode-155-Min-Stack","date":"2018-07-15T13:27:49.000Z","updated":"2018-07-16T10:27:05.573Z","comments":true,"path":"2018/07/15/Leetcode-155-Min-Stack/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/Leetcode-155-Min-Stack/","excerpt":"QuestionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2.","text":"QuestionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. ExplanationUsing an addition list to the minimum value every time the stack is updated. Therefore, getMin() will not take O(n) time complexity. Appending the new value to the end of the list will reduce the complexity of changing the stack. Code123456789101112131415161718192021222324252627282930313233343536373839class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.stack = [] self.min = [] def push(self, x): \"\"\" :type x: int :rtype: void \"\"\" self.stack.append(x) if not self.min or self.min[-1] &gt; x: self.min.append(x) else: self.min.append(self.min[-1]) def pop(self): \"\"\" :rtype: void \"\"\" self.stack.pop() self.min.pop() def top(self): \"\"\" :rtype: int \"\"\" return(self.stack[-1]) def getMin(self): \"\"\" :rtype: int \"\"\" return self.min[-1]","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"House Robber","slug":"House-Robber","date":"2018-07-15T10:13:38.000Z","updated":"2018-07-16T10:27:49.956Z","comments":true,"path":"2018/07/15/House-Robber/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/House-Robber/","excerpt":"QuestionYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.","text":"QuestionYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 &gt; (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money &gt; = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. ExplanationThe maximum value the robber can get when he comes to a house is nums[i]+max(nums[i-2], nums[i-3]) when i-3 and i-2 exist. Therefore, we can separate the question into two situations. The first one is to determine the max reward when i&lt;=3. The second one is to calculate the maximum value for i based on the maximum value we get in nums[i-2] and nums[i-3]. Codeclass Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 elif len(nums) &lt; 3: return max(nums) elif len(nums) == 3: return max(nums[1], nums[0]+nums[2]) else: nums[2] += nums[0] globalMax = max(nums[1], nums[2]) for i in range(3, len(nums)): nums[i] += max(nums[i-2], nums[i-3]) globalMax = max(globalMax, nums[i]) return globalMax","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Merge sorted array","slug":"Merge-sorted-array","date":"2018-07-13T12:11:43.000Z","updated":"2018-07-15T09:16:17.599Z","comments":true,"path":"2018/07/13/Merge-sorted-array/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/Merge-sorted-array/","excerpt":"QuestionGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.","text":"QuestionGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 思路由于两个数组都已经排序，因此可以从后往前比较两个数组，将较大的元素插入未排序的部分。若数组1先排完，则说明数组2的剩余元素均比数组1小，所以将剩余部分填充完即可；若数组2先排完，则说明数组1剩余元素均小于数组2，由于合并是在数组1上原地完成，因此不需要再操作。 Code123456789101112131415161718192021222324class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" end = m+n-1 m -= 1 n -= 1 while end &gt;= 0 and m &gt;= 0 and n &gt;= 0: if nums1[m] &gt; nums2[n]: nums1[end] = nums1[m] m -= 1 else: nums1[end] = nums2[n] n -= 1 end -= 1 while n &gt;= 0: nums1[end] = nums2[n] n -= 1 end -= 1","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"First bad version","slug":"First-bad-version","date":"2018-07-13T00:14:01.000Z","updated":"2018-07-15T09:16:39.785Z","comments":true,"path":"2018/07/13/First-bad-version/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/First-bad-version/","excerpt":"QuestionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.","text":"QuestionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions 1, 2, ..., n and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; true Then 4 is the first bad version. 思路要做到减少判断的次数，最先想到的是二分法，不断取中值进行判断，缩小搜索范围。如果mid是bad version那么mid可能是第一个bad version，所以将右边界缩小到mid；如果mid不是bad version，那么first bad version一定在mid右侧，所以将左边界缩小至mid左侧，这里left = mid+1很重要。举个例子： 还剩两个值,比如1， 2时，因为(1+2)//2 == 1，所以此时mid为1，假设1不是bad version， left = mid还是等于1，将会陷入死循环。 最后范围被压缩到一个值，这个值就是The first bad version。 Code123456789101112131415class Solution(object): def firstBadVersion(self, n): \"\"\" :type n: int :rtype: int \"\"\" left = 1 right = n while left != right: mid = (left+right)//2 if isBadVersion(mid): right = mid else: left = mid+1 # mid is not the first bad version return left","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Maximum Subarray","slug":"Maximim-Subarray","date":"2018-07-13T00:05:23.000Z","updated":"2018-07-15T09:16:29.483Z","comments":true,"path":"2018/07/13/Maximim-Subarray/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/Maximim-Subarray/","excerpt":"QuestionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.","text":"QuestionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle ExplanationAssume the local maximum is the maximum value of the continuous subarray which must contain the current value pointed by the index i. The function of local maximum can be expressed as localMax[i] = max(nums[i], localMax[i-1]+nums[i]). This can be explained by the examples below: if localMax[i-1]&gt;0, nums[i]&gt;0 then localMax[i] = localMax[i-1]+nums[i] if localMax[i-1]&gt;0, nums[i]&lt;0 then localMax[i] = localMax[i-1]+nums[i] if localMax[i-1]&lt;0, nums[i]&gt;0 then localMax[i] = nums[i] if localMax[i-1]&lt;0, nums[i]&lt;0 then localMax[i] = nums[i] We also need a globalMax to store the global maximum value. In this case, although we take localMax[i-1]+nums[i] as local maximum which is smaller than localMax[i-1] when localMax[i-1]&gt;0, nums[i]&lt;0, we are still able to keep the localMax[i-1] with the existence of globalMax. With these two variables, we can get maximum of subarray with O(n) time complexity and O(1) space complexity. Code1234567891011121314151617181920212223242526272829class Solution: def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int Two methods here, just select one. \"\"\" # Time complexity O(n); Space complexity O(n) local = [nums[0]] globalMax = nums[0] for i in range(1,len(nums)): if local[-1] &gt; 0: local.append(local[-1]+nums[i]) else: local.append(nums[i]) globalMax = max(globalMax, local[-1]) return globalMax # Time complexity O(n); Space complexity O(1) if len(nums) == 0: return None elif len(nums) == 1: return nums[0] localMax = nums[0] globalMax = nums[0] for x in nums[1:]: localMax = max(x, localMax+x) globalMax = max(localMax, globalMax) return globalMax","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]}]}