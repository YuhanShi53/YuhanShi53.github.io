{"meta":{"title":"Yuhan Shi","subtitle":"Han's blog","description":null,"author":"Yuhan Shi","url":"https://yuhanshi53.github.io"},"pages":[{"title":"Documents","date":"2018-07-13T14:23:57.470Z","updated":"2018-07-13T14:23:57.470Z","comments":true,"path":"categories/index.html","permalink":"https://yuhanshi53.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-07-14T15:02:15.374Z","updated":"2018-07-14T15:02:15.374Z","comments":false,"path":"about/index.html","permalink":"https://yuhanshi53.github.io/about/index.html","excerpt":"","text":"TBC"},{"title":"Tags","date":"2018-07-13T14:10:25.880Z","updated":"2018-07-13T14:10:25.880Z","comments":true,"path":"tags/index.html","permalink":"https://yuhanshi53.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode 2 - Add Two Numbers","slug":"Leetcode-2-Add-Two-Numbers","date":"2018-07-31T20:30:38.000Z","updated":"2018-07-31T22:20:11.211Z","comments":true,"path":"2018/07/31/Leetcode-2-Add-Two-Numbers/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/31/Leetcode-2-Add-Two-Numbers/","excerpt":"QuestionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.","text":"QuestionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Analysis这一道题在一刷的时候还没有特别的解决技巧，基本思路是分为三种情况： 两个链表节点都有值的时候，将两个节点的值加起来赋给新节点； 只有链表一的节点有值，将链表一节点的值赋给新节点 只有链表二的节点有值，将链表一节点的值赋给新节点这是最先想到的解法，代码在下方 Method One 中展示。 比较简化的思路是，只要链表一或者链表二存在有效值，就继续循环。如果链表一有值而链表二没有，则给链表二的节点赋值 ListNode(0) 用于计算；反之给链表一的节点赋值 ListNode(0)。这样操作省去了分情况讨论的复杂性，这个算法的代码在 Method Optimum 中展示。另外需要注意的是，当两个值相加超过9时，仅保留个位上的数字，并进位，因此需要额外的空间保存进位信息。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution: def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" # Method Two temp = ListNode(0) res = temp carry = 0 while l1 is not None or l2 is not None: l1 = l1 or ListNode(0) l2 = l2 or ListNode(0) total = l1.val+l2.val+carry carry = total//10 total %= 10 l1 = l1.next l2 = l2.next temp.next = ListNode(total) temp = temp.next if carry == 1: temp.next = ListNode(1) return res.next # Method One # temp = ListNode(0) # res = temp # addOne = 0 # while(l1 or l2 or addOne): # temp.next = ListNode(0) # temp = temp.next # if l1 and l2: # temp.val = l1.val+l2.val+addOne # l1 = l1.next # l2 = l2.next # elif l1: # temp.val = l1.val+addOne # l1 = l1.next # elif l2: # temp.val = l2.val+addOne # l2 = l2.next # else: # temp.val = 1 # addOne = temp.val // 10 # temp.val %= 10 # return res.next","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 334 - Increasing Triplet Subsequence","slug":"Leetcode-334-Increasing-Triplet-Subsequence","date":"2018-07-30T19:26:02.000Z","updated":"2018-07-30T18:48:57.750Z","comments":true,"path":"2018/07/30/Leetcode-334-Increasing-Triplet-Subsequence/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/30/Leetcode-334-Increasing-Triplet-Subsequence/","excerpt":"QuestionGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Note: Your algorithm should run in O(n) time complexity and O(1) space complexity. Example 1: Input: [1,2,3,4,5]Output: trueExample 2: Input: [5,4,3,2,1]Output: false","text":"QuestionGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Note: Your algorithm should run in O(n) time complexity and O(1) space complexity. Example 1: Input: [1,2,3,4,5]Output: trueExample 2: Input: [5,4,3,2,1]Output: false Analysis因为题目要求我们找到长度为3的递增子序列，因此我们可以设置两个指针 p1 和 p2，一个指向值较小的元素，一个指向值较大的元素在遍历序列的过程中，一旦遇到值比第二个值大，那么必然存在符合条件的子序列。在遍历的同时，如果遇到值小于 p1，则将新的值赋给 p1，如果新的值大于 p1， 小于 p2，则将新的值赋给 p2。这样做将递增序列的下限下调，便于更快地找到子序列第三个元素。 由于整个过程始终保证存在 p1 的值小于 p2，因此即便 p1 指向的值次序大于 p2, 一旦当前值大于 p2，一定能找到 p1 过去或现在的某个值组成递增序列。 Code123456789101112131415class Solution(object): def increasingTriplet(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" p1 = p2 = float('inf') for x in nums: if x &lt;= p1: p1 = x elif x &lt;= p2: p2 = x else: return True return False","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 101 - Symmetric Tree","slug":"Leetcode-101-Symmetric-Tree","date":"2018-07-20T15:47:30.000Z","updated":"2018-07-20T15:20:02.162Z","comments":true,"path":"2018/07/20/Leetcode-101-Symmetric-Tree/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/20/Leetcode-101-Symmetric-Tree/","excerpt":"QuestionGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3Note:Bonus points if you could solve it both recursively and iteratively.","text":"QuestionGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3Note:Bonus points if you could solve it both recursively and iteratively. Analysis要判断一个树是否对称，就是看同一层的节点是否关于中心对称。例如一层有8个节点，则应该有第一个节点值等于第八个节点值，第二个节点值等于第七个…因此在使用循环或者递归遍历树的的时候，应当使得每一步比较的两个节点位置关于中心对称。因此从每次向下遍历时，应当把每一层首位对应的两个节点送到下一步进行比较，而不是简单地把一个节点的左右子节点送到下一步。 Code12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def isSymmetric(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" # Iterate (Beat 100%) if root == None: return True stack = [root.left, root.right] while(stack): p, q = stack.pop(), stack.pop() if p == None and q == None: continue if p == None or q == None or p.val != q.val: return False stack.extend([p.left, q.right, p.right, q.left]) return True # Recursive# if root == None:# return True# return self.isSymmetricAssist(root.left, root.right) # def isSymmetricAssist(self, left, right):# \"\"\"# :type left: TreeNode# :type right: TreeNode# :rtype: bool# \"\"\"# if left == None or right == None:# return left == right# if left.val != right.val:# return False# return (self.isSymmetricAssist(left.left, right.right) and # self.isSymmetricAssist(left.right, right.left))","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"},{"name":"Algoroithms","slug":"Algoroithms","permalink":"https://yuhanshi53.github.io/tags/Algoroithms/"}]},{"title":"Leetcode 98 - Validate Binary Search Tree","slug":"Leetcode-98-Validate-Binary-Search-Tree","date":"2018-07-20T15:27:03.000Z","updated":"2018-07-20T14:44:10.737Z","comments":true,"path":"2018/07/20/Leetcode-98-Validate-Binary-Search-Tree/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/20/Leetcode-98-Validate-Binary-Search-Tree/","excerpt":"QuestionGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: Input: 2 / \\ 1 3 Output: true Example 2: 5 / \\ 1 4&nbsp; / \\&nbsp; 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node’s value&nbsp; is 5 but its right child’s value is 4.","text":"QuestionGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: Input: 2 / \\ 1 3 Output: true Example 2: 5 / \\ 1 4&nbsp; / \\&nbsp; 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node’s value&nbsp; is 5 but its right child’s value is 4. Analysis这道题需要判断对于每个节点其左边的子节点是不是都小于自身，同时右边的子节点是不是都大于自身。这种要求下使用中序遍历可以按照左节点-&gt;父节点-&gt;右节点的顺序，将树的每一个节点取出，并存在序列中。如果树是一个二叉搜索树，那么生成的序列中每一个元素都应当比其左边的元素大。如果比左边的元素小或者等于都说明不满足二叉搜索树的要求。 这里采用递归的方法遍历节点，根据中序遍历的顺序，先遍历左节点，再是父节点，最后是右节点。 Code12345678910111213141516171819202122232425class Solution(object): def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" if root == None: return True nodeOrder = [] self.nodeAppender(root, nodeOrder) for i in range(len(nodeOrder)-1): if nodeOrder[i] &gt;= nodeOrder[i+1]: return False return True def nodeAppender(self, root, nodeOrder): \"\"\" :type root: TreeNode :type nodeOrder: List[int] :rtype: No return \"\"\" if root: self.nodeAppender(root.left, nodeOrder) nodeOrder.append(root.val) self.nodeAppender(root.right, nodeOrder)","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 20 - Valid Parentheses","slug":"Leetcode-20-Valid-Parentheses","date":"2018-07-17T13:07:10.000Z","updated":"2018-07-17T12:15:39.294Z","comments":true,"path":"2018/07/17/Leetcode-20-Valid-Parentheses/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/17/Leetcode-20-Valid-Parentheses/","excerpt":"QuestionGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.Note that an empty string is also considered valid. Example 1: Input: “()”Output: true Example 2: Input: “()[]{}”Output: true Example 3: Input: “(]”Output: false Example 4: Input: “([)]”Output: false Example 5: Input: “{[]}”Output: true","text":"QuestionGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.Note that an empty string is also considered valid. Example 1: Input: “()”Output: true Example 2: Input: “()[]{}”Output: true Example 3: Input: “(]”Output: false Example 4: Input: “([)]”Output: false Example 5: Input: “{[]}”Output: true Analysis相比于采用多个 if else 来判断括号，使用字典储存括号对应关系并用于判断更加简洁。如果当前字符为 &#39;{([&#39; 之一，则往一个额外列表中添加左括号，否则如果额外列表为空，或者当前括号和额外列表最后一个括号不对应，则不符合规则。 Code1234567891011121314class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" dic = &#123;'&#123;': '&#125;', '(': ')', '[': ']'&#125; res = [] for x in s: if x in dic: res.append(x) elif not res or x != dic[res.pop()]: return False return not res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 268 - Missing Number","slug":"Leetcode-268-Missing-Number","date":"2018-07-17T12:55:13.000Z","updated":"2018-07-17T12:06:04.784Z","comments":true,"path":"2018/07/17/Leetcode-268-Missing-Number/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/17/Leetcode-268-Missing-Number/","excerpt":"QuestionGiven an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.","text":"QuestionGiven an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. Example 1: Input: [3,0,1]Output: 2 Example 2: Input: [9,6,4,2,3,5,7,0,1]Output: 8 Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Analysis因为 nums 的长度就是列表应有的最大值，因此获取列表长度后通过公式 $n(n+1)/2$ 就可以计算出列表应当有的和。用这个和减去列表实际的总和，就可以得出缺少的那一项。这个算法的时间复杂度为 $O(n)$，计算列表长度和列表总和需要遍历列表。空间复杂度为 $O(1)$。 Code12345678class Solution(object): def missingNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = len(nums) return n*(n+1)/2 - sum(nums)","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 13 - Roman to Integer","slug":"Leetcode-13-Roman-to-Integer","date":"2018-07-16T14:34:57.000Z","updated":"2018-07-16T13:55:06.264Z","comments":true,"path":"2018/07/16/Leetcode-13-Roman-to-Integer/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/16/Leetcode-13-Roman-to-Integer/","excerpt":"QuestionRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: “III”Output: 3Example 2: Input: “IV”Output: 4Example 3: Input: “IX”Output: 9Example 4: Input: “LVIII”Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3.Example 5: Input: “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.","text":"QuestionRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: “III”Output: 3Example 2: Input: “IV”Output: 4Example 3: Input: “IX”Output: 9Example 4: Input: “LVIII”Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3.Example 5: Input: “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Explanation因为包含特殊组合的罗马数字表示不同的含义，因此需要对 IXC 单独进行判断，但是常规方式的判断语句太多，不太简洁。简单的方式是将罗马数字逆序来看，如果是正常情况，则每一位罗马数字都应该不小于前一位，即 nums[i] &gt;= nums[i-1]。但如果需要通过组合表示 -1,-10,-100 的操作，则会出现当前一位罗马数字比前一位小的情况，例如 IV 的逆序 VI。nums[1] 小于 nums[0]，说明这里需要减去 nums[1] 即 1。重复以上的操作，当前位置数字大于等于前一位时，正常叠加，否则减去当前数字。 Code12345678910111213141516class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" dic = &#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; pre = 0 res = 0 for x in s[::-1]: if dic[x] &lt; pre: res -= dic[x] else: res += dic[x] pre = dic[x] return res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 326 - Power of Three","slug":"Leetcode-326-Power-of-Three","date":"2018-07-16T10:54:15.000Z","updated":"2018-07-16T10:27:38.715Z","comments":true,"path":"2018/07/16/Leetcode-326-Power-of-Three/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/16/Leetcode-326-Power-of-Three/","excerpt":"QuestionGiven an integer, write a function to determine if it is a power of three. Example 1: Input: 27Output: trueExample 2: Input: 0Output: falseExample 3: Input: 9Output: trueExample 4: Input: 45Output: false Follow up:Could you do it without using any loop / recursion?","text":"QuestionGiven an integer, write a function to determine if it is a power of three. Example 1: Input: 27Output: trueExample 2: Input: 0Output: falseExample 3: Input: 9Output: trueExample 4: Input: 45Output: false Follow up:Could you do it without using any loop / recursion? Explanation判断一个数 n 是不是3的幂，只需要以3为底求 n 的对数即可，是正整数返回 True ，否则返回 False 。代码中 log() 默认以 $e$ 为底，因此需要用到换底公式：$$log_{\\theta}{n} = \\frac{log_{\\epsilon}{n}}{log_{\\epsilon}{\\theta}}$$在 Python 中，由于精度的问题，求3为底 n 的对数可能得到不精确的结果，例如:12&gt;&gt;&gt; log(243,3)&gt;&gt;&gt; 4.999999999 因此需要将求出的对数四舍五入后作为3的指数求出结果，将结果和 n 对比，如果相等，则 n 是3的幂。 Code1234567891011from math import logclass Solution(object): def isPowerOfThree(self, n): \"\"\" :type n: int :rtype: bool \"\"\" if n &gt; 0: return 3**round(log(n,3)) == n return False","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 204 - Count Primes","slug":"Leetcode-204-Count-Primes","date":"2018-07-15T23:06:32.000Z","updated":"2018-07-16T10:26:41.674Z","comments":true,"path":"2018/07/16/Leetcode-204-Count-Primes/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/16/Leetcode-204-Count-Primes/","excerpt":"QuestionCount the number of prime numbers less than a non-negative number, n.","text":"QuestionCount the number of prime numbers less than a non-negative number, n. Example: Input: 10Output: 4Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Explanation判断一个数是否是质数最简单的方法是用所有比他小的正整数（1除外）去除它，如果都不能除尽，则这个数是质数，但是这样的时间复杂度将会是$O(n^2)$。这里需要用到埃拉托斯特尼筛法减少循环次数。埃拉托斯特尼筛法是从2开始，将2的正整数倍的数都标记为False，在之后的遍历过程中，标记为False的数将不再做素数的判断，因为他们都能被2整除。标记完之后，继续对下一个标记为True的数字（这里是3）进行筛选，直到最后一个数。如下为动态演示： source from wikipedia 这样筛选还是包含了一些不必要的计算，因为一个合数 $n$ 的因子必然小于 $ \\sqrt{n} $ ，因此对于 $ n \\in {1,N} $ ， 只需要排除小于 $ \\sqrt{N}+1 $ 的素数的倍数。至于大于等于 $ \\sqrt{n}+1 $ 的素数，它们的倍数要么被更小的素数筛完，要么大于 $N$ ，因此无需判断。 Code12345678910111213141516class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\" if n &lt; 2: return 0 nSqrt = int(n**0.5)+1 primeList = [True] * n primeList[0:2] = [False] * 2 for i in range(nSqrt): if primeList[i]: primeList[2*i:n:i] = [False]*len(range(2*i,n,i)) res = primeList.count(True) return res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 412 - Fizz Buzz","slug":"Leetcode-412-Fizz-Buzz","date":"2018-07-15T14:02:24.000Z","updated":"2018-07-16T10:27:20.019Z","comments":true,"path":"2018/07/15/Leetcode-412-Fizz-Buzz/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/Leetcode-412-Fizz-Buzz/","excerpt":"QuestionWrite a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.","text":"QuestionWrite a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15,Return:[ “1”, “2”, “Fizz”, “4”, “Buzz”, “Fizz”, “7”, “8”, “Fizz”, “Buzz”, “11”, “Fizz”, “13”, “14”, “FizzBuzz”] ExplanationThe judgement should judge i%15 first. Code12345678910111213141516171819class Solution(object): def fizzBuzz(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" if n == 0: return [] res = [] for i in range(1, n+1): if i%15 == 0: res.append('FizzBuzz') elif i%5 == 0: res.append('Buzz') elif i%3 == 0: res.append('Fizz') else: res.append(str(i)) return res","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Leetcode 155 - Min Stack","slug":"Leetcode-155-Min-Stack","date":"2018-07-15T13:27:49.000Z","updated":"2018-07-16T10:27:05.573Z","comments":true,"path":"2018/07/15/Leetcode-155-Min-Stack/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/Leetcode-155-Min-Stack/","excerpt":"QuestionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2.","text":"QuestionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; Returns -3.minStack.pop();minStack.top(); –&gt; Returns 0.minStack.getMin(); –&gt; Returns -2. ExplanationUsing an addition list to the minimum value every time the stack is updated. Therefore, getMin() will not take O(n) time complexity. Appending the new value to the end of the list will reduce the complexity of changing the stack. Code123456789101112131415161718192021222324252627282930313233343536373839class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.stack = [] self.min = [] def push(self, x): \"\"\" :type x: int :rtype: void \"\"\" self.stack.append(x) if not self.min or self.min[-1] &gt; x: self.min.append(x) else: self.min.append(self.min[-1]) def pop(self): \"\"\" :rtype: void \"\"\" self.stack.pop() self.min.pop() def top(self): \"\"\" :rtype: int \"\"\" return(self.stack[-1]) def getMin(self): \"\"\" :rtype: int \"\"\" return self.min[-1]","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"House Robber","slug":"House-Robber","date":"2018-07-15T10:13:38.000Z","updated":"2018-07-16T10:27:49.956Z","comments":true,"path":"2018/07/15/House-Robber/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/15/House-Robber/","excerpt":"QuestionYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.","text":"QuestionYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 &gt; (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money &gt; = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. ExplanationThe maximum value the robber can get when he comes to a house is nums[i]+max(nums[i-2], nums[i-3]) when i-3 and i-2 exist. Therefore, we can separate the question into two situations. The first one is to determine the max reward when i&lt;=3. The second one is to calculate the maximum value for i based on the maximum value we get in nums[i-2] and nums[i-3]. Codeclass Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums) == 0: return 0 elif len(nums) &lt; 3: return max(nums) elif len(nums) == 3: return max(nums[1], nums[0]+nums[2]) else: nums[2] += nums[0] globalMax = max(nums[1], nums[2]) for i in range(3, len(nums)): nums[i] += max(nums[i-2], nums[i-3]) globalMax = max(globalMax, nums[i]) return globalMax","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Merge sorted array","slug":"Merge-sorted-array","date":"2018-07-13T12:11:43.000Z","updated":"2018-07-15T09:16:17.599Z","comments":true,"path":"2018/07/13/Merge-sorted-array/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/Merge-sorted-array/","excerpt":"QuestionGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.","text":"QuestionGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 思路由于两个数组都已经排序，因此可以从后往前比较两个数组，将较大的元素插入未排序的部分。若数组1先排完，则说明数组2的剩余元素均比数组1小，所以将剩余部分填充完即可；若数组2先排完，则说明数组1剩余元素均小于数组2，由于合并是在数组1上原地完成，因此不需要再操作。 Code123456789101112131415161718192021222324class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" end = m+n-1 m -= 1 n -= 1 while end &gt;= 0 and m &gt;= 0 and n &gt;= 0: if nums1[m] &gt; nums2[n]: nums1[end] = nums1[m] m -= 1 else: nums1[end] = nums2[n] n -= 1 end -= 1 while n &gt;= 0: nums1[end] = nums2[n] n -= 1 end -= 1","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"First bad version","slug":"First-bad-version","date":"2018-07-13T00:14:01.000Z","updated":"2018-07-15T09:16:39.785Z","comments":true,"path":"2018/07/13/First-bad-version/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/First-bad-version/","excerpt":"QuestionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.","text":"QuestionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions 1, 2, ..., n and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; true Then 4 is the first bad version. 思路要做到减少判断的次数，最先想到的是二分法，不断取中值进行判断，缩小搜索范围。如果mid是bad version那么mid可能是第一个bad version，所以将右边界缩小到mid；如果mid不是bad version，那么first bad version一定在mid右侧，所以将左边界缩小至mid左侧，这里left = mid+1很重要。举个例子： 还剩两个值,比如1， 2时，因为(1+2)//2 == 1，所以此时mid为1，假设1不是bad version， left = mid还是等于1，将会陷入死循环。 最后范围被压缩到一个值，这个值就是The first bad version。 Code123456789101112131415class Solution(object): def firstBadVersion(self, n): \"\"\" :type n: int :rtype: int \"\"\" left = 1 right = n while left != right: mid = (left+right)//2 if isBadVersion(mid): right = mid else: left = mid+1 # mid is not the first bad version return left","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]},{"title":"Maximum Subarray","slug":"Maximim-Subarray","date":"2018-07-13T00:05:23.000Z","updated":"2018-07-15T09:16:29.483Z","comments":true,"path":"2018/07/13/Maximim-Subarray/","link":"","permalink":"https://yuhanshi53.github.io/2018/07/13/Maximim-Subarray/","excerpt":"QuestionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.","text":"QuestionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle ExplanationAssume the local maximum is the maximum value of the continuous subarray which must contain the current value pointed by the index i. The function of local maximum can be expressed as localMax[i] = max(nums[i], localMax[i-1]+nums[i]). This can be explained by the examples below: if localMax[i-1]&gt;0, nums[i]&gt;0 then localMax[i] = localMax[i-1]+nums[i] if localMax[i-1]&gt;0, nums[i]&lt;0 then localMax[i] = localMax[i-1]+nums[i] if localMax[i-1]&lt;0, nums[i]&gt;0 then localMax[i] = nums[i] if localMax[i-1]&lt;0, nums[i]&lt;0 then localMax[i] = nums[i] We also need a globalMax to store the global maximum value. In this case, although we take localMax[i-1]+nums[i] as local maximum which is smaller than localMax[i-1] when localMax[i-1]&gt;0, nums[i]&lt;0, we are still able to keep the localMax[i-1] with the existence of globalMax. With these two variables, we can get maximum of subarray with O(n) time complexity and O(1) space complexity. Code1234567891011121314151617181920212223242526272829class Solution: def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int Two methods here, just select one. \"\"\" # Time complexity O(n); Space complexity O(n) local = [nums[0]] globalMax = nums[0] for i in range(1,len(nums)): if local[-1] &gt; 0: local.append(local[-1]+nums[i]) else: local.append(nums[i]) globalMax = max(globalMax, local[-1]) return globalMax # Time complexity O(n); Space complexity O(1) if len(nums) == 0: return None elif len(nums) == 1: return nums[0] localMax = nums[0] globalMax = nums[0] for x in nums[1:]: localMax = max(x, localMax+x) globalMax = max(localMax, globalMax) return globalMax","categories":[{"name":"Documents","slug":"Documents","permalink":"https://yuhanshi53.github.io/categories/Documents/"},{"name":"Algorithms","slug":"Documents/Algorithms","permalink":"https://yuhanshi53.github.io/categories/Documents/Algorithms/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://yuhanshi53.github.io/tags/Leetcode/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://yuhanshi53.github.io/tags/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://yuhanshi53.github.io/tags/Python/"}]}]}